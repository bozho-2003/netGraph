# This python script is for analysing h264 meat data which contain some information such
# as bps, qp, time and so on.
# This python script will produce a new file which contain information in one second.
# 
# You have to install python module pylibpcap, which is an implementation of pcap.
# Install command for mac: pip install pylibpcap
#
# 

import sys
from grammarparser import grammar_parse
from grammarparser import grammar_parse_keyexpression
from grammarparser import grammar_parse_keyexpression_generate
from grammarparser import grammar_parse_keyexpression_del_property
from grammarparser import grammar_parse_keyexpression_modify_property
from grammarparser import grammar_parse_keyexpression_list
from grammarparser import grammar_parse_insert_keyexpression
from grammarparser import grammar_parse_generate_string
from grammarparser import grammar_parse_keyexpression_get_name

class pcapMetaInfo():
    """
    Version 1.0
    The packet meta information is like this:
    {PacketInfo --> protocol=rtp version=2 len=40 headerlen=6 clocktime=Timt_11_09_14 second=1465960154 millisecond=367 source_address=IP_10_140_81_26 destination_address=IP_10_140_81_123;}
    {PacketInfo --> protocol=rtp version=2 len=28 headerlen=6 clocktime=Timt_11_09_14 second=1465960154 millisecond=368 source_address=IP_10_140_81_26 destination_address=IP_10_140_81_123;}
    {PacketInfo --> protocol=rtp version=2 len=1040 headerlen=6 clocktime=Timt_11_09_15 second=1465960155 millisecond=21 source_address=IP_10_140_81_26 destination_address=IP_10_140_81_123;}
    {PacketInfo --> protocol=rtp version=2 len=1009 headerlen=6 clocktime=Timt_11_09_15 second=1465960155 millisecond=24 source_address=IP_10_140_81_26 destination_address=IP_10_140_81_123;}

    And generate a meta information string like this:
    {{Pps   -->   type="rtp" second=1465960154 total_len=68 rtp_num=2 total_payload_len=20 total_payload_len_kbps=747 packet_len=[40 28 ] header_len=[6 6 ] packet_millisecond=[367 368] ;}}
    {{Pps   -->   type="rtp" second=1465960155 total_len=68 rtp_num=2 total_payload_len=20 total_payload_len_kbps=747 packet_len=[40 28 ] header_len=[6 6 ] packet_millisecond=[367 368] ;}}
   
    This class is dedigned for parsing network packet meta information which is organized in the form which is described in file grammerparse.py.
    These methods are essential, including parser_string(self, whole_string), update_meta_info(self), update_meta_global_info(self, info_in),
    generate_meta_info_string(self), get_meta_string(self), clean_meta_info(self), clean_meta_string(self).
    You can use these method in this way.

    Sample Code likes this:

    metaInstance = plyH264MetaParser.H264MetaInfo()
    metaInstance.parser_string(meta_string)
    metaInstance.update_meta_info()
    iRes = metaInstance.generate_meta_info_string()
    if iRes:
        str_out = metaInstance.get_meta_string()
        metaInstance.clean_meta_info()
    """    
    # 
    version = 1.0
    def __init__(self):
        self.initial_second = 0
        self.packet_info_list = []
        
        # string which will be generated by this list
        self.store_list = []
        self.meta_string = ""
        self.packet_per_second_list = []
        self.idx = 0

    def __clean_iter_info(self):
        self.packet_info_list = []

    # This method is public method which will be called by outer program.
    def clean_meta_info(self):
        self.store_list = []
        self.packet_per_second_list = []
        self.meta_string = ""

    # This method is public method which will be called by outer program.
    def update_meta_global_info(self, info_in):
        '''
        Update the global information.
        '''
        index_range = range(len(self.store_list))
        for index in index_range:
            if type(self.store_list[index]) == tuple:
                if self.store_list[index][0] == info_in[0]:
                    self.store_list[index] = info_in
                    return 

        grammar_parse_insert_keyexpression(self.store_list, info_in)
        return 

    # This method is public method which will be called by outer program.
    def parser_string(self, whole_string):
        '''
        Parse the string.
        You can call this funciton with part of the string several times, and this will act in the same way just like
        calling this function one time with all string.
        {PacketInfo --> protocol=rtp version=2 len=1009 headerlen=6 clocktime=Timt_11_09_15 second=1465960155 millisecond=24 source_address=IP_10_140_81_26 destination_address=IP_10_140_81_123;}
        '''
        result = grammar_parse(whole_string)
        # This will be stored in a permanent file.
        #        
        for x in result:
            if type(x) == tuple:
                pass
            elif type(x) == list:
                list_tmp0 = grammar_parse_keyexpression_list(x, 'PacketInfo')
                if list_tmp0: 
                    # Get packet protocal
                    flag,packetType = grammar_parse_keyexpression(list_tmp0[0], 'PacketInfo', 'protocol')
                    flag,packetLen = grammar_parse_keyexpression(list_tmp0[0], 'PacketInfo', 'len')
                    flag,packetHeaderLen = grammar_parse_keyexpression(list_tmp0[0], 'PacketInfo', 'headerlen')
                    flag,clocktime = grammar_parse_keyexpression(list_tmp0[0], 'PacketInfo', 'clocktime')
                    flag,second = grammar_parse_keyexpression(list_tmp0[0], 'PacketInfo', 'second')
                    flag,millisecond = grammar_parse_keyexpression(list_tmp0[0], 'PacketInfo', 'millisecond')
                
                    packetinfo_dict_val = {}
                    packetinfo_dict_val['type'] = packetType
                    packetinfo_dict_val['len'] = packetLen
                    packetinfo_dict_val['headerlen'] = packetHeaderLen
                    packetinfo_dict_val['clocktime'] = clocktime
                    packetinfo_dict_val['second'] = second
                    packetinfo_dict_val['millisecond'] = millisecond
                    
                    self.packet_info_list.append(packetinfo_dict_val)

    # This method is public method which will be called by outer program.
    def update_meta_info(self):
        '''
        Get the statistics information of one second line BPS(Byte pre second)
        Of course this funciton will left the meta information which is not used to deal with
        in the next time when you call this function.
        '''
        # Insert bps information list into store_list
        max_index = len(self.packet_info_list)
        index_range = range(max_index)
        for index in index_range:
            packet_type = self.packet_info_list[index]['type']
            packet_len = self.packet_info_list[index]['len']
            packet_header_len = self.packet_info_list[index]['headerlen']
            packet_second = self.packet_info_list[index]['second']
            packet_millisecond = self.packet_info_list[index]['millisecond']

            if self.initial_second == 0:
                self.initial_second = packet_second
                self.current_second_dict = {}
                self.current_second_dict['millisecond'] = []
                self.current_second_dict['len'] = []
                self.current_second_dict['headerlen'] = []

            if self.initial_second != packet_second:
                # This Mean that a new second has begun, so we need store the last second information.
                total_len = reduce(lambda sum_all, x : sum_all + x, self.current_second_dict['len'])
                total_header_len = reduce(lambda sum_all, x : sum_all + x, self.current_second_dict['headerlen'])

                pps_second = grammar_parse_keyexpression_generate('Pps')
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'type', self.current_second_dict['type'])
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'second', self.current_second_dict['second'])
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'total_len', total_len)
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'rtp_num', len(self.current_second_dict['len']))
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'total_payload_len', total_len - total_header_len * 4)
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'total_payload_len_kbps', (total_len - total_header_len * 4)*8/1000 + 1)
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'packet_len', self.current_second_dict['len'])
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'header_len', self.current_second_dict['headerlen'])
                grammar_parse_keyexpression_modify_property(pps_second, 'Pps', 'packet_millisecond', self.current_second_dict['millisecond'])

                grammar_parse_insert_keyexpression(self.packet_per_second_list, pps_second)

                self.initial_second = packet_second
                self.current_second_dict = {}
                self.current_second_dict['millisecond'] = []
                self.current_second_dict['len'] = []
                self.current_second_dict['headerlen'] = []

            self.current_second_dict['type'] = packet_type
            self.current_second_dict['second'] = packet_second
            self.current_second_dict['millisecond'].append(packet_millisecond)
            self.current_second_dict['len'].append(packet_len)
            self.current_second_dict['headerlen'].append(packet_header_len)
        self.packet_info_list = []

    # This method is public method which will be called by outer program.
    def generate_meta_info_string(self):
        if self.packet_per_second_list:
            tmp_list = []
            tmp_list.extend(self.store_list)
            pps_information_list = []
            grammar_parse_insert_keyexpression(pps_information_list, self.packet_per_second_list)
            # Insert bps information list into store_list
            # Store golbal guple in a file
            grammar_parse_insert_keyexpression(tmp_list, pps_information_list)
            self.meta_string = grammar_parse_generate_string(tmp_list)
            return True
        return False

    # This method is public method which will be called by outer program.
    def get_meta_string(self):
        return self.meta_string

    # This method is public method which will be called by outer program.
    def clean_meta_string(self):
        self.meta_string = ""

class pcapMetaInfoDraw():
    # This is class static parameter.
    """
    Version 1.0
    The packet meta information is like this:
    {{Pps   -->   type="rtp" second=1465960154 total_len=68 rtp_num=2 total_payload_len=20 total_payload_len_kbps=747 packet_len=[40 28 ] header_len=[6 6 ] packet_millisecond=[367 368] ;}}
    {{Pps   -->   type="rtp" second=1465960155 total_len=68 rtp_num=2 total_payload_len=20 total_payload_len_kbps=747 packet_len=[40 28 ] header_len=[6 6 ] packet_millisecond=[367 368] ;}}
   
    This class is dedigned for parsing network summary meta information which is organized in the form which is described in file grammerparse.py.
    These methods are essential, including parser_string(self, whole_string), get_global_info(self), get_info(self).
    
    You can use these method in this way.
    Sample Code likes this:

    pcapMetaDrawInstance = pcapMetaParser.pcapMetaInfoDraw()
    pcapMetaDrawInstance.parse_string(str_meta)
    info_list = pcapMetaDrawInstance.get_info()
                 
    """
    version = 1.0
    def __init__(self):
        self.pps_info_list = []
        
    def parse_string(self, whole_string):
        if type(whole_string) == list:
            result = whole_string
        else:
            result = grammar_parse(whole_string)
        for x in result:
            if type(x) == tuple:
                pass          
            elif type(x) == list:
                Pps_list =  grammar_parse_keyexpression_list(x, 'Pps')
                for iter in Pps_list:
                    pps_dict_val = {}
                    
                    flag, val = grammar_parse_keyexpression(iter, 'Pps', 'type')
                    pps_dict_val['type'] = val
                    flag, val = grammar_parse_keyexpression(iter, 'Pps', 'second')
                    pps_dict_val['second'] = val
                    flag, val = grammar_parse_keyexpression(iter, 'Pps', 'total_payload_len')
                    pps_dict_val['total_payload_len'] = val
                    flag, val = grammar_parse_keyexpression(iter, 'Pps', 'total_payload_len_kbps')
                    pps_dict_val['total_payload_len_kbps'] = val

                    self.pps_info_list.append(pps_dict_val)
                    
    def get_info(self):
        return self.pps_info_list

    def get_global_info(self):
        return None

if __name__ == "__main__":
    from optparse import OptionParser
    import os, sys
    # Parse the command line options
    parser = OptionParser (usage = "Usage: " + sys.argv[0] + " [Options]")
    parser.add_option ("-f", "--file=", dest = 'file', default=None, help="file which will be analysed.")
    options, other_argv = parser.parse_args ()

    filename = options.file
    filename_out = filename +  ".parseout"
    if not os.path.exists(filename_out):
        print "File " + filename_out + " don't exist. So we generate it."
        f = open(filename,"r")
        whole_line = f.read()
        f.close()

        packetMetaInstance =  pcapMetaInfo()
            
        # Generate output file.
        packetMetaInstance.parser_string(whole_line)
        packetMetaInstance.update_meta_info()
        packetMetaInstance.generate_meta_info_string()            
        str_out = packetMetaInstance.get_meta_string()
        f_out = open(filename_out,"w")
        f_out.write(str_out)
        f_out.close()
        print "Gerenate file - "+ filename_out + " Done"
        f.close()

        pcapMetaDrawInstance = pcapMetaInfoDraw()
        pcapMetaDrawInstance.parse_string(str_out)
        l_out = pcapMetaDrawInstance.get_info()
        for iter in l_out:
            print iter
        print "Done"

